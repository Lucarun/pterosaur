
<com.rabbitmq.client.impl.ChannelN: void basicAck(long,boolean)>


package com.rabbitmq.client.impl;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.AlreadyClosedException;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Command;
import com.rabbitmq.client.ConfirmCallback;
import com.rabbitmq.client.ConfirmListener;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.ConsumerShutdownSignalCallback;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.rabbitmq.client.Envelope;
import com.rabbitmq.client.GetResponse;
import com.rabbitmq.client.MessageProperties;
import com.rabbitmq.client.Method;
import com.rabbitmq.client.MetricsCollector;
import com.rabbitmq.client.NoOpMetricsCollector;
import com.rabbitmq.client.Return;
import com.rabbitmq.client.ReturnCallback;
import com.rabbitmq.client.ReturnListener;
import com.rabbitmq.client.ShutdownSignalException;
import com.rabbitmq.client.UnexpectedMethodError;
import com.rabbitmq.client.observation.ObservationCollector;
import com.rabbitmq.utility.Utility;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeoutException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ChannelN extends AMQChannel implements Channel {

        public void basicAck(long deliveryTag, boolean multiple) throws IOException {
            this.transmit(new AMQImpl.Basic.Ack(deliveryTag, multiple));
            this.metricsCollector.basicAck(this, deliveryTag, multiple);
        }
}


//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.rabbitmq.client.impl;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.AlreadyClosedException;
import com.rabbitmq.client.ChannelContinuationTimeoutException;
import com.rabbitmq.client.Command;
import com.rabbitmq.client.Method;
import com.rabbitmq.client.ShutdownSignalException;
import com.rabbitmq.client.TrafficListener;
import com.rabbitmq.client.observation.ObservationCollector;
import com.rabbitmq.utility.BlockingValueOrException;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Supplier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class AMQChannel extends ShutdownNotifierComponent {
    private static final Logger LOGGER = LoggerFactory.getLogger(AMQChannel.class);
    protected static final int NO_RPC_TIMEOUT = 0;
    protected final Lock _channelLock = new ReentrantLock();
    protected final Condition _channelLockCondition;
    private final AMQConnection _connection;
    private final int _channelNumber;
    private AMQCommand _command;
    private RpcWrapper _activeRpc;
    protected volatile boolean _blockContent;
    protected final int _rpcTimeout;
    private final boolean _checkRpcResponseType;
    private final TrafficListener _trafficListener;
    private final int maxInboundMessageBodySize;
    private final ObservationCollector.ConnectionInfo connectionInfo;

    public AMQChannel(AMQConnection connection, int channelNumber) {
        this._channelLockCondition = this._channelLock.newCondition();
        this._activeRpc = null;
        this._blockContent = false;
        this._connection = connection;
        this._channelNumber = channelNumber;
        if (connection.getChannelRpcTimeout() < 0) {
            throw new IllegalArgumentException("Continuation timeout on RPC calls cannot be less than 0");
        } else {
            this._rpcTimeout = connection.getChannelRpcTimeout();
            this._checkRpcResponseType = connection.willCheckRpcResponseType();
            this._trafficListener = connection.getTrafficListener();
            this.maxInboundMessageBodySize = connection.getMaxInboundMessageBodySize();
            this._command = new AMQCommand(this.maxInboundMessageBodySize);
            this.connectionInfo = connection.connectionInfo();
        }
    }

    public int getChannelNumber() {
        return this._channelNumber;
    }

    public void handleFrame(Frame frame) throws IOException {
        AMQCommand command = this._command;
        if (command.handleFrame(frame)) {
            this._command = new AMQCommand(this.maxInboundMessageBodySize);
            this.handleCompleteInboundCommand(command);
        }

    }

    public static IOException wrap(ShutdownSignalException ex) {
        return wrap(ex, (String)null);
    }

    public static IOException wrap(ShutdownSignalException ex, String message) {
        IOException ioe = new IOException(message);
        ioe.initCause(ex);
        return ioe;
    }

    public AMQCommand exnWrappingRpc(Method m) throws IOException {
        try {
            return this.privateRpc(m);
        } catch (AlreadyClosedException var3) {
            throw var3;
        } catch (ShutdownSignalException var4) {
            throw wrap(var4);
        }
    }

    public CompletableFuture<Command> exnWrappingAsyncRpc(Method m) throws IOException {
        try {
            return this.privateAsyncRpc(m);
        } catch (AlreadyClosedException var3) {
            throw var3;
        } catch (ShutdownSignalException var4) {
            throw wrap(var4);
        }
    }

    public void handleCompleteInboundCommand(AMQCommand command) throws IOException {
        this._trafficListener.read(command);
        if (!this.processAsync(command)) {
            if (this._checkRpcResponseType) {
                label68: {
                    this._channelLock.lock();

                    try {
                        if (this._activeRpc == null || this._activeRpc.canHandleReply(command)) {
                            break label68;
                        }
                    } finally {
                        this._channelLock.unlock();
                    }

                    return;
                }
            }

            RpcWrapper nextOutstandingRpc = this.nextOutstandingRpc();
            if (nextOutstandingRpc != null) {
                nextOutstandingRpc.complete(command);
                this.markRpcFinished();
            }
        }

    }

    public void enqueueRpc(RpcContinuation k) {
        this.doEnqueueRpc(() -> {
            return new RpcContinuationRpcWrapper(k);
        });
    }

    public void enqueueAsyncRpc(Method method, CompletableFuture<Command> future) {
        this.doEnqueueRpc(() -> {
            return new CompletableFutureRpcWrapper(method, future);
        });
    }

    private void doEnqueueRpc(Supplier<RpcWrapper> rpcWrapperSupplier) {
        this._channelLock.lock();

        try {
            boolean waitClearedInterruptStatus = false;

            while(this._activeRpc != null) {
                try {
                    this._channelLockCondition.await();
                } catch (InterruptedException var7) {
                    waitClearedInterruptStatus = true;
                }
            }

            if (waitClearedInterruptStatus) {
                Thread.currentThread().interrupt();
            }

            this._activeRpc = (RpcWrapper)rpcWrapperSupplier.get();
        } finally {
            this._channelLock.unlock();
        }

    }

    public boolean isOutstandingRpc() {
        this._channelLock.lock();

        boolean var1;
        try {
            var1 = this._activeRpc != null;
        } finally {
            this._channelLock.unlock();
        }

        return var1;
    }

    public RpcWrapper nextOutstandingRpc() {
        this._channelLock.lock();

        RpcWrapper var2;
        try {
            RpcWrapper result = this._activeRpc;
            this._activeRpc = null;
            this._channelLockCondition.signalAll();
            var2 = result;
        } finally {
            this._channelLock.unlock();
        }

        return var2;
    }

    protected void markRpcFinished() {
    }

    public void ensureIsOpen() throws AlreadyClosedException {
        if (!this.isOpen()) {
            throw new AlreadyClosedException(this.getCloseReason());
        }
    }

    public AMQCommand rpc(Method m) throws IOException, ShutdownSignalException {
        return this.privateRpc(m);
    }

    public AMQCommand rpc(Method m, int timeout) throws IOException, ShutdownSignalException, TimeoutException {
        return this.privateRpc(m, timeout);
    }

    private AMQCommand privateRpc(Method m) throws IOException, ShutdownSignalException {
        SimpleBlockingRpcContinuation k = new SimpleBlockingRpcContinuation(m);
        this.rpc(m, k);
        if (this._rpcTimeout == 0) {
            return (AMQCommand)k.getReply();
        } else {
            try {
                return (AMQCommand)k.getReply(this._rpcTimeout);
            } catch (TimeoutException var4) {
                throw this.wrapTimeoutException(m, var4);
            }
        }
    }

    private void cleanRpcChannelState() {
        try {
            this.nextOutstandingRpc();
            this.markRpcFinished();
        } catch (Exception var2) {
            LOGGER.warn("Error while cleaning timed out channel RPC: {}", var2.getMessage());
        }

    }

    protected ChannelContinuationTimeoutException wrapTimeoutException(Method m, TimeoutException e) {
        this.cleanRpcChannelState();
        return new ChannelContinuationTimeoutException(e, this, this._channelNumber, m);
    }

    private CompletableFuture<Command> privateAsyncRpc(Method m) throws IOException, ShutdownSignalException {
        CompletableFuture<Command> future = new CompletableFuture();
        this.asyncRpc(m, future);
        return future;
    }

    private AMQCommand privateRpc(Method m, int timeout) throws IOException, ShutdownSignalException, TimeoutException {
        SimpleBlockingRpcContinuation k = new SimpleBlockingRpcContinuation(m);
        this.rpc(m, k);

        try {
            return (AMQCommand)k.getReply(timeout);
        } catch (TimeoutException var5) {
            this.cleanRpcChannelState();
            throw var5;
        }
    }

    public void rpc(Method m, RpcContinuation k) throws IOException {
        this._channelLock.lock();

        try {
            this.ensureIsOpen();
            this.quiescingRpc(m, k);
        } finally {
            this._channelLock.unlock();
        }

    }

    public void quiescingRpc(Method m, RpcContinuation k) throws IOException {
        this._channelLock.lock();

        try {
            this.enqueueRpc(k);
            this.quiescingTransmit(m);
        } finally {
            this._channelLock.unlock();
        }

    }

    public void asyncRpc(Method m, CompletableFuture<Command> future) throws IOException {
        this._channelLock.lock();

        try {
            this.ensureIsOpen();
            this.quiescingAsyncRpc(m, future);
        } finally {
            this._channelLock.unlock();
        }

    }

    public void quiescingAsyncRpc(Method m, CompletableFuture<Command> future) throws IOException {
        this._channelLock.lock();

        try {
            this.enqueueAsyncRpc(m, future);
            this.quiescingTransmit(m);
        } finally {
            this._channelLock.unlock();
        }

    }

    public abstract boolean processAsync(Command var1) throws IOException;

    public String toString() {
        return "AMQChannel(" + this._connection + "," + this._channelNumber + ")";
    }

    public void processShutdownSignal(ShutdownSignalException signal, boolean ignoreClosed, boolean notifyRpc) {
        try {
            this._channelLock.lock();

            try {
                if (!this.setShutdownCauseIfOpen(signal) && !ignoreClosed) {
                    throw new AlreadyClosedException(this.getCloseReason());
                }

                this._channelLockCondition.signalAll();
            } finally {
                this._channelLock.unlock();
            }
        } finally {
            if (notifyRpc) {
                this.notifyOutstandingRpc(signal);
            }

        }

    }

    public void notifyOutstandingRpc(ShutdownSignalException signal) {
        RpcWrapper k = this.nextOutstandingRpc();
        if (k != null) {
            k.shutdown(signal);
        }

    }

    public void transmit(Method m) throws IOException {
        this._channelLock.lock();

        try {
            this.transmit(new AMQCommand(m));
        } finally {
            this._channelLock.unlock();
        }

    }

    public void transmit(AMQCommand c) throws IOException {
        this._channelLock.lock();

        try {
            this.ensureIsOpen();
            this.quiescingTransmit(c);
        } finally {
            this._channelLock.unlock();
        }

    }

    public void quiescingTransmit(Method m) throws IOException {
        this._channelLock.lock();

        try {
            this.quiescingTransmit(new AMQCommand(m));
        } finally {
            this._channelLock.unlock();
        }

    }

    public void quiescingTransmit(AMQCommand c) throws IOException {
        this._channelLock.lock();

        try {
            if (c.getMethod().hasContent()) {
                for(; this._blockContent; this.ensureIsOpen()) {
                    try {
                        this._channelLockCondition.await();
                    } catch (InterruptedException var6) {
                        Thread.currentThread().interrupt();
                    }
                }
            }

            this._trafficListener.write(c);
            c.transmit(this);
        } finally {
            this._channelLock.unlock();
        }

    }

    public AMQConnection getConnection() {
        return this._connection;
    }

    protected ObservationCollector.ConnectionInfo connectionInfo() {
        return this.connectionInfo;
    }

    public static class SimpleBlockingRpcContinuation extends BlockingRpcContinuation<AMQCommand> {
        public SimpleBlockingRpcContinuation() {
        }

        public SimpleBlockingRpcContinuation(Method method) {
            super(method);
        }

        public AMQCommand transformReply(AMQCommand command) {
            return command;
        }
    }

    public abstract static class BlockingRpcContinuation<T> implements RpcContinuation {
        public final BlockingValueOrException<T, ShutdownSignalException> _blocker = new BlockingValueOrException();
        protected final Method request;

        public BlockingRpcContinuation() {
            this.request = null;
        }

        public BlockingRpcContinuation(Method request) {
            this.request = request;
        }

        public void handleCommand(AMQCommand command) {
            this._blocker.setValue(this.transformReply(command));
        }

        public void handleShutdownSignal(ShutdownSignalException signal) {
            this._blocker.setException(signal);
        }

        public T getReply() throws ShutdownSignalException {
            return this._blocker.uninterruptibleGetValue();
        }

        public T getReply(int timeout) throws ShutdownSignalException, TimeoutException {
            return this._blocker.uninterruptibleGetValue(timeout);
        }

        public boolean canHandleReply(AMQCommand command) {
            return isResponseCompatibleWithRequest(this.request, command.getMethod());
        }

        public abstract T transformReply(AMQCommand var1);

        public static boolean isResponseCompatibleWithRequest(Method request, Method response) {
            if (request != null) {
                if (request instanceof AMQP.Basic.Qos) {
                    return response instanceof AMQP.Basic.QosOk;
                }

                if (request instanceof AMQP.Basic.Get) {
                    return response instanceof AMQP.Basic.GetOk || response instanceof AMQP.Basic.GetEmpty;
                }

                if (request instanceof AMQP.Basic.Consume) {
                    if (!(response instanceof AMQP.Basic.ConsumeOk)) {
                        return false;
                    }

                    String consumerTag = ((AMQP.Basic.Consume)request).getConsumerTag();
                    return consumerTag == null || consumerTag.equals("") || consumerTag.equals(((AMQP.Basic.ConsumeOk)response).getConsumerTag());
                }

                if (request instanceof AMQP.Basic.Cancel) {
                    if (!(response instanceof AMQP.Basic.CancelOk)) {
                        return false;
                    }

                    return ((AMQP.Basic.Cancel)request).getConsumerTag().equals(((AMQP.Basic.CancelOk)response).getConsumerTag());
                }

                if (request instanceof AMQP.Basic.Recover) {
                    return response instanceof AMQP.Basic.RecoverOk;
                }

                if (request instanceof AMQP.Exchange.Declare) {
                    return response instanceof AMQP.Exchange.DeclareOk;
                }

                if (request instanceof AMQP.Exchange.Delete) {
                    return response instanceof AMQP.Exchange.DeleteOk;
                }

                if (request instanceof AMQP.Exchange.Bind) {
                    return response instanceof AMQP.Exchange.BindOk;
                }

                if (request instanceof AMQP.Exchange.Unbind) {
                    return response instanceof AMQP.Exchange.UnbindOk;
                }

                if (request instanceof AMQP.Queue.Declare) {
                    return response instanceof AMQP.Queue.DeclareOk;
                }

                if (request instanceof AMQP.Queue.Delete) {
                    return response instanceof AMQP.Queue.DeleteOk;
                }

                if (request instanceof AMQP.Queue.Bind) {
                    return response instanceof AMQP.Queue.BindOk;
                }

                if (request instanceof AMQP.Queue.Unbind) {
                    return response instanceof AMQP.Queue.UnbindOk;
                }

                if (request instanceof AMQP.Queue.Purge) {
                    return response instanceof AMQP.Queue.PurgeOk;
                }

                if (request instanceof AMQP.Tx.Select) {
                    return response instanceof AMQP.Tx.SelectOk;
                }

                if (request instanceof AMQP.Tx.Commit) {
                    return response instanceof AMQP.Tx.CommitOk;
                }

                if (request instanceof AMQP.Tx.Rollback) {
                    return response instanceof AMQP.Tx.RollbackOk;
                }

                if (request instanceof AMQP.Confirm.Select) {
                    return response instanceof AMQP.Confirm.SelectOk;
                }
            }

            return true;
        }
    }

    public interface RpcContinuation {
        void handleCommand(AMQCommand var1);

        boolean canHandleReply(AMQCommand var1);

        void handleShutdownSignal(ShutdownSignalException var1);
    }
}


//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.rabbitmq.client.impl;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.MetricsCollector;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class AbstractMetricsCollector implements MetricsCollector {
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractMetricsCollector.class);
    private final ConcurrentMap<String, ConnectionState> connectionState = new ConcurrentHashMap();
    private final Runnable markAcknowledgedMessageAction = () -> {
        this.markAcknowledgedMessage();
    };
    private final Runnable markRejectedMessageAction = () -> {
        this.markRejectedMessage();
    };

    public AbstractMetricsCollector() {
    }

    public void newConnection(Connection connection) {
        try {
            if (connection.getId() == null) {
                connection.setId(UUID.randomUUID().toString());
            }

            this.incrementConnectionCount(connection);
            this.connectionState.put(connection.getId(), new ConnectionState(connection));
            connection.addShutdownListener((cause) -> {
                this.closeConnection(connection);
            });
        } catch (Exception var3) {
            LOGGER.info("Error while computing metrics in newConnection: " + var3.getMessage());
        }

    }

    public void closeConnection(Connection connection) {
        try {
            ConnectionState removed = (ConnectionState)this.connectionState.remove(connection.getId());
            if (removed != null) {
                this.decrementConnectionCount(connection);
            }
        } catch (Exception var3) {
            LOGGER.info("Error while computing metrics in closeConnection: " + var3.getMessage());
        }

    }

    public void newChannel(Channel channel) {
        if (channel != null) {
            try {
                this.incrementChannelCount(channel);
                channel.addShutdownListener((cause) -> {
                    this.closeChannel(channel);
                });
                this.connectionState(channel.getConnection()).channelState.put(channel.getChannelNumber(), new ChannelState(channel));
            } catch (Exception var3) {
                LOGGER.info("Error while computing metrics in newChannel: " + var3.getMessage());
            }
        }

    }

    public void closeChannel(Channel channel) {
        try {
            ChannelState removed = (ChannelState)this.connectionState(channel.getConnection()).channelState.remove(channel.getChannelNumber());
            if (removed != null) {
                this.decrementChannelCount(channel);
            }
        } catch (Exception var3) {
            LOGGER.info("Error while computing metrics in closeChannel: " + var3.getMessage());
        }

    }

    public void basicPublish(Channel channel) {
        try {
            this.markPublishedMessage();
        } catch (Exception var3) {
            LOGGER.info("Error while computing metrics in basicPublish: " + var3.getMessage());
        }

    }

    public void basicPublishFailure(Channel channel, Throwable cause) {
        try {
            this.markMessagePublishFailed();
        } catch (Exception var4) {
            LOGGER.info("Error while computing metrics in basicPublishFailure: " + var4.getMessage());
        }

    }

    public void basicPublishAck(Channel channel, long deliveryTag, boolean multiple) {
        if (!multiple) {
            try {
                this.markMessagePublishAcknowledged();
            } catch (Exception var6) {
                LOGGER.info("Error while computing metrics in basicPublishAck: " + var6.getMessage());
            }

        }
    }

    public void basicPublishNack(Channel channel, long deliveryTag, boolean multiple) {
        if (!multiple) {
            try {
                this.markMessagePublishNotAcknowledged();
            } catch (Exception var6) {
                LOGGER.info("Error while computing metrics in basicPublishNack: " + var6.getMessage());
            }

        }
    }

    public void basicPublishUnrouted(Channel channel) {
        try {
            this.markPublishedMessageUnrouted();
        } catch (Exception var3) {
            LOGGER.info("Error while computing metrics in markPublishedMessageUnrouted: " + var3.getMessage());
        }

    }

    public void basicConsume(Channel channel, String consumerTag, boolean autoAck) {
        try {
            if (!autoAck) {
                ChannelState channelState = this.channelState(channel);
                channelState.lock.lock();

                try {
                    this.channelState(channel).consumersWithManualAck.add(consumerTag);
                } finally {
                    channelState.lock.unlock();
                }
            }
        } catch (Exception var9) {
            LOGGER.info("Error while computing metrics in basicConsume: " + var9.getMessage());
        }

    }

    public void basicCancel(Channel channel, String consumerTag) {
        try {
            ChannelState channelState = this.channelState(channel);
            channelState.lock.lock();

            try {
                this.channelState(channel).consumersWithManualAck.remove(consumerTag);
            } finally {
                channelState.lock.unlock();
            }
        } catch (Exception var8) {
            LOGGER.info("Error while computing metrics in basicCancel: " + var8.getMessage());
        }

    }

    public void consumedMessage(Channel channel, long deliveryTag, boolean autoAck) {
        try {
            this.markConsumedMessage();
            if (!autoAck) {
                ChannelState channelState = this.channelState(channel);
                channelState.lock.lock();

                try {
                    this.channelState(channel).unackedMessageDeliveryTags.add(deliveryTag);
                } finally {
                    channelState.lock.unlock();
                }
            }
        } catch (Exception var10) {
            LOGGER.info("Error while computing metrics in consumedMessage: " + var10.getMessage());
        }

    }

    public void consumedMessage(Channel channel, long deliveryTag, String consumerTag) {
        try {
            this.markConsumedMessage();
            ChannelState channelState = this.channelState(channel);
            channelState.lock.lock();

            try {
                if (channelState.consumersWithManualAck.contains(consumerTag)) {
                    channelState.unackedMessageDeliveryTags.add(deliveryTag);
                }
            } finally {
                channelState.lock.unlock();
            }
        } catch (Exception var10) {
            LOGGER.info("Error while computing metrics in consumedMessage: " + var10.getMessage());
        }

    }

    public void basicAck(Channel channel, long deliveryTag, boolean multiple) {
        try {
            this.updateChannelStateAfterAckReject(channel, deliveryTag, multiple, this.markAcknowledgedMessageAction);
        } catch (Exception var6) {
            LOGGER.info("Error while computing metrics in basicAck: " + var6.getMessage());
        }

    }

    public void basicNack(Channel channel, long deliveryTag) {
        try {
            this.updateChannelStateAfterAckReject(channel, deliveryTag, true, this.markRejectedMessageAction);
        } catch (Exception var5) {
            LOGGER.info("Error while computing metrics in basicNack: " + var5.getMessage());
        }

    }

    public void basicReject(Channel channel, long deliveryTag) {
        try {
            this.updateChannelStateAfterAckReject(channel, deliveryTag, false, this.markRejectedMessageAction);
        } catch (Exception var5) {
            LOGGER.info("Error while computing metrics in basicReject: " + var5.getMessage());
        }

    }

    private void updateChannelStateAfterAckReject(Channel channel, long deliveryTag, boolean multiple, Runnable action) {
        ChannelState channelState = this.channelState(channel);
        channelState.lock.lock();

        try {
            if (multiple) {
                Iterator<Long> iterator = channelState.unackedMessageDeliveryTags.iterator();

                while(iterator.hasNext()) {
                    long messageDeliveryTag = (Long)iterator.next();
                    if (messageDeliveryTag <= deliveryTag) {
                        iterator.remove();
                        action.run();
                    }
                }
            } else if (channelState.unackedMessageDeliveryTags.remove(deliveryTag)) {
                action.run();
            }
        } finally {
            channelState.lock.unlock();
        }

    }

    private ConnectionState connectionState(Connection connection) {
        return (ConnectionState)this.connectionState.get(connection.getId());
    }

    private ChannelState channelState(Channel channel) {
        return (ChannelState)this.connectionState(channel.getConnection()).channelState.get(channel.getChannelNumber());
    }

    public void cleanStaleState() {
        try {
            Iterator<Map.Entry<String, ConnectionState>> connectionStateIterator = this.connectionState.entrySet().iterator();

            while(true) {
                while(connectionStateIterator.hasNext()) {
                    Map.Entry<String, ConnectionState> connectionEntry = (Map.Entry)connectionStateIterator.next();
                    Connection connection = ((ConnectionState)connectionEntry.getValue()).connection;
                    if (connection.isOpen()) {
                        Iterator<Map.Entry<Integer, ChannelState>> channelStateIterator = ((ConnectionState)connectionEntry.getValue()).channelState.entrySet().iterator();

                        while(channelStateIterator.hasNext()) {
                            Map.Entry<Integer, ChannelState> channelStateEntry = (Map.Entry)channelStateIterator.next();
                            Channel channel = ((ChannelState)channelStateEntry.getValue()).channel;
                            if (!channel.isOpen()) {
                                channelStateIterator.remove();
                                this.decrementChannelCount(channel);
                                LOGGER.info("Ripped off state of channel {} of connection {}. This is abnormal, please report.", channel.getChannelNumber(), connection.getId());
                            }
                        }
                    } else {
                        connectionStateIterator.remove();
                        this.decrementConnectionCount(connection);

                        for(int i = 0; i < ((ConnectionState)connectionEntry.getValue()).channelState.size(); ++i) {
                            this.decrementChannelCount((Channel)null);
                        }

                        LOGGER.info("Ripped off state of connection {}. This is abnormal, please report.", connection.getId());
                    }
                }

                return;
            }
        } catch (Exception var7) {
            LOGGER.info("Error during periodic clean of metricsCollector: " + var7.getMessage());
        }
    }

    protected abstract void incrementConnectionCount(Connection var1);

    protected abstract void decrementConnectionCount(Connection var1);

    protected abstract void incrementChannelCount(Channel var1);

    protected abstract void decrementChannelCount(Channel var1);

    protected abstract void markPublishedMessage();

    protected abstract void markMessagePublishFailed();

    protected abstract void markConsumedMessage();

    protected abstract void markAcknowledgedMessage();

    protected abstract void markRejectedMessage();

    protected abstract void markMessagePublishAcknowledged();

    protected abstract void markMessagePublishNotAcknowledged();

    protected abstract void markPublishedMessageUnrouted();

    private static class ChannelState {
        final Lock lock;
        final Set<Long> unackedMessageDeliveryTags;
        final Set<String> consumersWithManualAck;
        final Channel channel;

        private ChannelState(Channel channel) {
            this.lock = new ReentrantLock();
            this.unackedMessageDeliveryTags = new HashSet();
            this.consumersWithManualAck = new HashSet();
            this.channel = channel;
        }
    }

    private static class ConnectionState {
        final ConcurrentMap<Integer, ChannelState> channelState;
        final Connection connection;

        private ConnectionState(Connection connection) {
            this.channelState = new ConcurrentHashMap();
            this.connection = connection;
        }
    }
}
